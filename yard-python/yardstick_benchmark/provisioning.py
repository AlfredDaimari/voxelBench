import time
from plumbum import local
from yardstick_benchmark.model import Node, VagrantNode
from pathlib import Path
from types import SimpleNamespace
import os
import toml
import subprocess


class Das(object):
    def __init__(self):
        self._reservation_map = dict()

    def _wait_for_ready(self, reservation_number: int) -> None:
        preserve = local["preserve"]
        ready = False
        while not ready:
            llist = preserve["-llist"]()
            for line in llist.split("\n")[3:]:
                parts = line.split()
                r = int(parts[0])
                if reservation_number == r:
                    ready = parts[6] == "R"
                    break
            if not ready:
                time.sleep(1)

    def _get_machines(self, reservation_number: int) -> list[str]:
        preserve = local["preserve"]
        llist = preserve["-llist"]()
        for line in llist.split("\n")[3:]:
            parts = line.split()
            r = int(parts[0])
            if reservation_number == r:
                return parts[8:]
        raise KeyError(f"reservation {reservation_number} does not exist")

    def provision(self, num=1, time_s=900) -> list[Node]:
        preserve = local["preserve"]
        reservation = int(preserve["-np", num, "-t", time_s]().split()[2][:-1])
        self._wait_for_ready(reservation)
        machines = self._get_machines(reservation)
        res = [
            Node(host=host, wd=Path(f"/local/{os.getlogin()}/yardstick/{host}"))
            for host in machines
        ]
        self._reservation_map[reservation] = set(res)
        return res

    def _cancel_reservation(self, number: int) -> None:
        preserve = local["preserve"]
        preserve["-c", number]()

    def release(self, machines: list[Node]) -> None:
        machines_to_release = set(machines)
        reservations_to_cancel = set()
        for item in self._reservation_map.items():
            item[1].difference_update(machines_to_release)
            if len(item[1]) == 0:
                reservations_to_cancel.add(item[0])
        for reservation in reservations_to_cancel:
            self._cancel_reservation(reservation)
            del self._reservation_map[reservation]


class VagrantVMs:
    # This class does not create Vagrant virtual machines, this class uses
    # data generated by the vanage.sh bash script in the vagrant directory
    # It reads information from the inventory file
    def __init__(self):
        self._inventory_file = Path(__file__).parent.parent.parent / "vagrant/inventory"

        with open(self._inventory_file, "r") as f:
            self._data = toml.loads(f.read())

            os.chdir(str(self._inventory_file.parent))
            env: subprocess._ENV = os.environ.copy()

            # check if master/worker nodes are running
            env["VAGRANT_VAGRANTFILE"] = "MultVagrantfile.rb"

            result = subprocess.run(
                "vagrant status", shell=True, capture_output=True, text=True, env=env
            )
            total_nodes_running: int = sum(
                1 for line in result.stdout.splitlines() if "running (libvirt)" in line
            )

            """
            Warning: vagrant status is problematic, removes all private files if it
            can't find the necessary nodes

            env["VAGRANT_VAGRANTFILE"] = "BotVagrantfile.rb"
            result = subprocess.run(
                "vagrant status", shell=True, capture_output=True, text=True, env=env
            )
            total_nodes_running += sum(
                1 for line in result.stdout.splitlines() if "running (libvirt)" in line
            )

            """

            total_inventory_file_nodes = 0
            for node_type in ["master", "worker", "bot"]:
                if node_type in self._data:
                    total_inventory_file_nodes += len(self._data[node_type])

            #assert total_nodes_running == total_inventory_file_nodes

    def _unpack(self, tag: str) -> list[VagrantNode]:
        nodes = []
        for n in self._data[tag]:
            node = SimpleNamespace(**n)
            nodes.append(
                VagrantNode(
                    node.name,
                    node.ansible_host,
                    node.ansible_user,
                    node.ansible_ssh_private_key_file,
                    node.ansible_ssh_common_args,
                    node.wd,
                    node.memory,
                )
            )

        return nodes

    def get_vms_with_tag(self, tag: str) -> list[VagrantNode]:
        if tag == "master" or tag == "worker" or tag == "bot":
            if tag in self._data:
                return self._unpack(tag)
            else:
                return []
        else:
            return self._unpack("master") + self._unpack("worker")
