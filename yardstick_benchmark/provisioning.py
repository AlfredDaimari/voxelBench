import time
from plumbum import local
from yardstick_benchmark.model import Node, VagrantNode
from pathlib import Path
from types import SimpleNamespace
import os
import toml
import subprocess


class Das(object):
    def __init__(self):
        self._reservation_map = dict()

    def _wait_for_ready(self, reservation_number: int) -> None:
        preserve = local["preserve"]
        ready = False
        while not ready:
            llist = preserve["-llist"]()
            for line in llist.split("\n")[3:]:
                parts = line.split()
                r = int(parts[0])
                if reservation_number == r:
                    ready = parts[6] == "R"
                    break
            if not ready:
                time.sleep(1)

    def _get_machines(self, reservation_number: int) -> list[str]:
        preserve = local["preserve"]
        llist = preserve["-llist"]()
        for line in llist.split("\n")[3:]:
            parts = line.split()
            r = int(parts[0])
            if reservation_number == r:
                return parts[8:]
        raise KeyError(f"reservation {reservation_number} does not exist")

    def provision(self, num=1, time_s=900) -> list[Node]:
        preserve = local["preserve"]
        reservation = int(preserve["-np", num, "-t", time_s]().split()[2][:-1])
        self._wait_for_ready(reservation)
        machines = self._get_machines(reservation)
        res = [
            Node(host=host, wd=Path(f"/local/{os.getlogin()}/yardstick/{host}"))
            for host in machines
        ]
        self._reservation_map[reservation] = set(res)
        return res

    def _cancel_reservation(self, number: int) -> None:
        preserve = local["preserve"]
        preserve["-c", number]()

    def release(self, machines: list[Node]) -> None:
        machines_to_release = set(machines)
        reservations_to_cancel = set()
        for item in self._reservation_map.items():
            item[1].difference_update(machines_to_release)
            if len(item[1]) == 0:
                reservations_to_cancel.add(item[0])
        for reservation in reservations_to_cancel:
            self._cancel_reservation(reservation)
            del self._reservation_map[reservation]


class VagrantVMs:
    # This class does not create Vagrant virtual machines, this class uses
    # data generated by the vanage.sh bash script in the vagrant directory
    # It reads information from the inventory file
    def __init__(self):
        self._inventory_file = Path(__file__).parent.parent / "vagrant/inventory"

        with open(self._inventory_file, "r") as f:
            self._data = toml.loads(f.read())

            # check if nodes are running
            os.chdir(str(self._inventory_file.parent))
            result = subprocess.run(
                "vagrant status", shell=True, capture_output=True, text=True
            )

            total_nodes_running: int = sum(
                1 for line in result.stdout.splitlines() if "running" in line
            )
            total_inventory_file_nodes: int = (
                len(self._data["worker"]) + len(self._data["bot"]) + 1
            )

            assert total_nodes_running == total_inventory_file_nodes

    def _unpack_master(self) -> list[VagrantNode]:
        node = SimpleNamespace(**self._data["master"])
        return [
            VagrantNode(
                node.name,
                node.ansible_host,
                node.ansible_user,
                node.ansible_ssh_private_key_file,
                node.ansible_ssh_common_args,
            )
        ]

    def _unpack_others(self, tag: str) -> list[VagrantNode]:
        nodes = []
        for n in self._data[tag]:
            node = SimpleNamespace(**n)
            nodes.append(
                VagrantNode(
                    node.name,
                    node.ansible_host,
                    node.ansible_user,
                    node.ansible_ssh_private_key_file,
                    node.ansible_ssh_common_args,
                )
            )

        return nodes

    def get_vms_with_tag(self, tag: str) -> list[VagrantNode]:
        if tag == "master":
            return self._unpack_master()

        elif tag == "worker":
            return self._unpack_others("worker")
        elif tag == "bot":
            return self._unpack_others("bot")
        else:
            return self._unpack_master() + self._unpack_others("worker")
